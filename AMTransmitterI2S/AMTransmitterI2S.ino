//code by bitluni (send me a high five if you like the code)

//replace this include file by your header file generated by the conversion tool
#include "sample.h"

#include <soc/rtc.h>
#include "driver/i2s.h"
#include "freertos/queue.h"
#include "SPIFFS.h"

static const i2s_port_t i2s_num = (i2s_port_t)I2S_NUM_0; // i2s port number

//static i2s_config_t i2s_config;
static const i2s_config_t i2s_config = {
     .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_DAC_BUILT_IN),
     .sample_rate = 44100  ,//not really used
     .bits_per_sample = (i2s_bits_per_sample_t)I2S_BITS_PER_SAMPLE_16BIT, 
     .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,
     .communication_format = I2S_COMM_FORMAT_I2S_MSB,
     .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
     .dma_buf_count = 2,
     .dma_buf_len = 1024,  //big buffers to avoid noises
     .use_apll = false
};

#define CCCC(c1, c2, c3, c4)    ((c4 << 24) | (c3 << 16) | (c2 << 8) | c1)

/* these are data structures to process wav file */
typedef enum headerState_e {
    HEADER_RIFF, HEADER_FMT, HEADER_DATA, DATA
} headerState_t;

typedef struct wavRiff_s {
    uint32_t chunkID;
    uint32_t chunkSize;
    uint32_t format;
} wavRiff_t;

typedef struct wavProperties_s {
    uint32_t chunkID;
    uint32_t chunkSize;
    uint16_t audioFormat;
    uint16_t numChannels;
    uint32_t sampleRate;
    uint32_t byteRate;
    uint16_t blockAlign;
    uint16_t bitsPerSample;
} wavProperties_t;
/* variables hold file, state of process wav file and wav file properties */    
File root,root2;
headerState_t state = HEADER_RIFF;
wavProperties_t wavProps;


int i2s_write_sample_nb(uint8_t sample){
  return i2s_write_bytes((i2s_port_t)i2s_num, (const char *)&sample, sizeof(uint8_t), portMAX_DELAY);
}
/* read 4 bytes of data from wav file */
int read4bytes(File file, uint32_t *chunkId){
  int n = file.read((uint8_t *)chunkId, sizeof(uint32_t));
  return n;
}

int readbyte(File file, uint8_t *chunkId){
  int n = file.read((uint8_t *)chunkId, sizeof(uint8_t));
  return n;
}

/* these are function to process wav file */
int readRiff(File file, wavRiff_t *wavRiff){
  int n = file.read((uint8_t *)wavRiff, sizeof(wavRiff_t));
  return n;
}
int readProps(File file, wavProperties_t *wavProps){
  int n = file.read((uint8_t *)wavProps, sizeof(wavProperties_t));
  return n;
}

void openf()
{
  int n;
 root = SPIFFS.open("/dd2.wav");
 wavRiff_t wavRiff;
        n = readRiff(root, &wavRiff);
        if(n == sizeof(wavRiff_t)){
          if(wavRiff.chunkID == CCCC('R', 'I', 'F', 'F') && wavRiff.format == CCCC('W', 'A', 'V', 'E')){
            state = HEADER_FMT;
            Serial.println("HEADER_RIFF");
          }
        }
   
        n = readProps(root, &wavProps);
        if(n == sizeof(wavProperties_t)){
          state = HEADER_DATA;
        }
  
        uint32_t chunkId, chunkSize;
        n = read4bytes(root, &chunkId);
        if(n == 4){
          if(chunkId == CCCC('d', 'a', 't', 'a')){
            Serial.println("HEADER_DATA");
          }
        }
        n = read4bytes(root, &chunkSize);
        if(n == 4){
          Serial.println("prepare data");
          state = DATA;
        }
        root2=root;
}

void setup() 
{
int n;
 static uint8_t buf[1024];
  Serial.begin(115200);
  Serial.print("Initializing SD card...");
  
  Serial.println("initialization done.");
  delay(1000);
  /* open wav file and process it */
  
         SPIFFS.begin();
     int levels=1;
     File root = SPIFFS.open("/");
      File file = root.openNextFile();
    while(file){
        if(file.isDirectory()){
            Serial.print("  DIR : ");
            Serial.println(file.name());
 
        } else {
            Serial.print("  FILE: ");
            Serial.print(file.name());
            Serial.print("  SIZE: ");
            Serial.println(file.size());
             file.read(buf, 512);
            Serial.printf("bytes in %d\n %s\n",2,buf);
        }
        file = root.openNextFile();
    }
  Serial.begin(115200);
  rtc_clk_cpu_freq_set(RTC_CPU_FREQ_240M);              //highest cpu frequency
  i2s_driver_install(i2s_num, &i2s_config, 0, NULL);    //start i2s driver
  i2s_set_pin(i2s_num, NULL);                           //use internal DAC
  i2s_set_sample_rates(i2s_num, 44100);               //dummy sample rate, since the function fails at high values
openf();
  //this is the hack that enables the highest sampling rate possible ~13MHz, have fun
 /* SET_PERI_REG_BITS(I2S_CLKM_CONF_REG(0), I2S_CLKM_DIV_A_V, 1, I2S_CLKM_DIV_A_S);
  SET_PERI_REG_BITS(I2S_CLKM_CONF_REG(0), I2S_CLKM_DIV_B_V, 1, I2S_CLKM_DIV_B_S);
  SET_PERI_REG_BITS(I2S_CLKM_CONF_REG(0), I2S_CLKM_DIV_NUM_V, 2, I2S_CLKM_DIV_NUM_S); 
  SET_PERI_REG_BITS(I2S_SAMPLE_RATE_CONF_REG(0), I2S_TX_BCK_DIV_NUM_V, 2, I2S_TX_BCK_DIV_NUM_S); */
}

//buffer to store modulated samples, I2S samples of the esp32 are always 16Bit
short buff[1024];
//sine represented in 16 values. at 13MHz sampling rate the resulting carrier is at around 835KHz
int sintab[] = {0, 48, 90, 117, 127, 117, 90, 48, 0, -48, -90, -117, -127, -117, -90, -48};

unsigned long long pos = 0;         //current position in the audio sample, using fixed point
unsigned int posLow = 0;
unsigned long long posInc = ((unsigned long long)sampleRate << 32) / 835000;  //sample fixed increment

void loop() 
{
  int n;
  //fill the sound buffer
  for(int i = 0; i < 1024; i++)
  {
    if(!root.available())
    {
      Serial.println("onchange");
      openf();
    }
     uint8_t data; 
      n = readbyte(root, &data);
      buff[i]=data;

  }
  //write the buffer (waits until a buffer is ready to be filled, that's timing for free)
  i2s_write_bytes(i2s_num, (char*)buff, sizeof(buff), portMAX_DELAY);
  Serial.println("ee");
}
